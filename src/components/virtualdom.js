import React from "react";

const VirtualDom = () => {
  return (
    <div className="headertext">
      <div className="virtualdom">
        <h1>Virtual Dom</h1>
        <h3>
          Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его
          легковесной копией. Мы можем вносить изменения в копию, исходя из
          наших потребностей, а после этого применять изменения к реальному DOM.
          При этом происходит сравнение DOM-дерева с его виртуальной копией,
          определяется разница и запускается перерисовка того, что было
          изменено.
        </h3>
        <h3>
          Такой подход работает быстрее, потому как не включает в себя все
          тяжеловесные части реального DOM. Но только если мы делаем это
          правильно. Есть две проблемы: когда именно делать повторную
          перерисовку DOM и как это сделать эффективно.
        </h3>

        <h2>Когда?</h2>
        <h3>
          Когда данные изменяются и нуждается в обновлении. Есть два варианта
          узнать, что данные изменились:
        </h3>
        <ul>
          <li>
            Первый из них — «dirty checking» (грязная проверка) заключается в
            том, чтобы опрашивать данные через регулярные промежутки времени и
            рекурсивно проверять все значения в структуре данных.{" "}
          </li>
          <li>
            Второй вариант — «observable» (наблюдаемый) заключается в наблюдении
            за изменением состояния. Если ничего не изменилось, мы ничего не
            делаем. Если изменилось, мы точно знаем, что нужно обновить.
          </li>
        </ul>
        <h2>Как?</h2>

        <h3>Что делает этот подход действительно быстрым:</h3>
        <ul>
          <li>Эффективные алгоритмы сравнения </li>
          <li>Группировка операций чтения/записи при работе с DOM</li>
          <li>Эффективное обновление только под-деревьев</li>
        </ul>
      </div>
    </div>
  );
};
export { VirtualDom };
